#!/usr/bin/python3

# ~/dev/py/xlattice_py/verifyContentKeys

import os
import re
import sys
import time
from argparse import ArgumentParser

from xlattice import (__version__, __version_date__,
                      Q, check_using_sha, u,
                      parseUsingSHA, fix_using_sha, show_using_sha, check_u_path)

# PATs AND REs ######################################################
DIR_NAME_PAT = '^[0-9a-fA-F]{2}$'
DIR_NAME_RE = re.compile(DIR_NAME_PAT)

# the default SHA2 or SHA3-based file name
FILE_NAME_PAT256 = '^[0-9a-fA-F]{64}$'

# the SHA1-based alternative
FILE_NAME_PAT1 = '^[0-9a-fA-F]{40}$'


def doLeafDir(args, subSub):
    count = 0
    files = sorted(os.listdir(subSub))
    for file in files:
        pathTo = os.path.join(subSub, file)
        if args.fileNameRegex.match(file):
            count += 1
            if args.using_sha == Q.USING_SHA1:
                hashAsHex = u.fileSHA1(pathTo)
            elif args.using_sha == Q.USING_SHA2:
                hashAsHex = u.fileSHA2(pathTo)
            elif args.using_sha == Q.USING_SHA3:
                hashAsHex = u.fileSHA3(pathTo)
            if args.verbose:
                print('      ' + pathTo)
            if hashAsHex != file:
                print("%s has content key %s" % (pathTo, hashAsHex))
        else:
            print("not a proper leaf file name: " + pathTo)
    args.count += count


def doSubDir(args, subDir):
    files = sorted(os.listdir(subDir))
    for subSub in files:
        pathTo = os.path.join(subDir, subSub)
        if DIR_NAME_RE.match(subSub):
            if args.verbose:
                print('    ' + pathTo)
            doLeafDir(args, pathTo)
        else:
            print("not a proper subsubdirectory: " + pathTo)


def doWhatever(args):
    args.count = 0
    u_path = args.u_path
    if args.verbose:
        print(u_path)
    files = sorted(os.listdir(u_path))
    for subDir in files:
        pathTo = os.path.join(u_path, subDir)
        if DIR_NAME_RE.match(subDir):
            if args.verbose:
                print('  ' + pathTo)
            doSubDir(args, pathTo)
        elif    subDir != 'L'       and\
                subDir != 'in'      and\
                subDir != 'node_id'  and\
                subDir != 'tmp':
            print("not a proper subdirectory: " + pathTo)
    print("processed %u files" % args.count)


def main():

    pgmNameAndVersion = "verifyContentKey v%s %s" % (
        __version__, __version_date__)
    timestamp = "%04d%02d%02d-%02d%02d%02d" % time.gmtime()[:6]

    # -- program defaults -------------------------------------------
    keyLen = 32

    # -- check for config file --------------------------------------

    # -- parse the command line -------------------------------------
    # see docs.python.org/library/argparse.html
    parser = ArgumentParser()

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show args and exit')

    parser.add_argument('-t', '--showTimestamp', action='store_true',
                        help='show run timestamp')

    # uPath: just the base name (usually Upax or Upax0) we will fix this up
    # below

    parser.add_argument('-T', '--testing', action='store_true',
                        help='test run - write to ./testU')

    parser.add_argument('-V', '--showVersion', action='store_true',
                        help='show version number and date')

    parseUsingSHA(parser)

    args = parser.parse_args()      # a Namespace object

    # -- fixups -----------------------------------------------------
    fix_using_sha(args)

    args.pgmNameAndVersion = pgmNameAndVersion
    args.timestamp = timestamp
    if args.using_sha:
        print("DEBUG: using SHA1 *** ")
        args.fileNameRegex = re.compile(FILE_NAME_PAT1)
    else:
        # USING_SHA2 and USING_SHA3
        args.fileNameRegex = re.compile(FILE_NAME_PAT256)

    # -- sanity checks ----------------------------------------------
    check_using_sha(args.using_sha)
    check_u_path(parser, args, mustExist=True)

    # fixups --------------------------------------------------------
    if args.u_path and args.u_path[-1] == '/':
        args.u_path = args.u_path[:-1]          # drop any trailing slash

    # -- do it ------------------------------------------------------

    # DEBUG
    print("THIS CODE HAS NOT BEEN TESTED")
    # END

    if args.verbose or args.showVersion or args.justShow:
        print(args.pgmNameAndVersion)
    if args.showTimestamp:
        print('run at %s GMT' % timestamp)   # could be prettier
    else:
        print()                               # there's a comma up there

    if args.justShow or args.verbose:
        print('justShow         = ' + str(args.justShow))
        print('showTimestamp    = ' + str(args.showTimestamp))
        print('showVersion      = ' + str(args.showVersion))
        print('timestamp        = ' + str(args.timestamp))
        show_using_sha(args)

    if not args.justShow:
        lock = u.ULock(args.u_path)
        try:
            if lock.get_lock():
                if args.verbose:
                    print('have lock on ' + args.u_path)
                doWhatever(args)
            else:
                print('could not get lock on %s' % args.u_path)
        finally:
            if args.verbose:
                print('releasing lock on ' + args.u_path)
            lock.release_lock()

if __name__ == '__main__':
    main()
